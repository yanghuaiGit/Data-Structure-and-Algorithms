<h2>排序</h2>
<img src="https://static001.geekbang.org/resource/image/fb/cd/fb8394a588b12ff6695cfd664afb17cd.jpg"/>
插入排序和冒泡排序的时间复杂度相同都是O(n2)，在实际的软件开发中，为什么更倾向于使用插入排序而不是冒泡排序？
<p>分析排序算法的执行效率</p>
<li>最好情况，最坏情况，平均情况时间复杂度</li>
<li>时间复杂度的系数,常数，低阶</li>
<li>比较次数和交换(或移动)次数</li>
<p>排序算法的内存消耗</p>
原地排序算法特指空间复杂度是O(1)的排序算法
<p>排序算法的稳定性，如果待排序的序列中存在值相等的元素，在经过排序之后，相等元素之间原有的先后顺序不变</p>
冒泡排序中数据的交换操作：
<p>  if (a[j] > a[j+1]) { // 交换</p>
<p>  int tmp = a[j];</p>
<p>  a[j] = a[j+1];</p>
<p>   a[j+1] = tmp;</p>
<p>  flag = true;</p>
<p>  }</p>

插入排序中数据的移动操作：
<p>if (a[j] > value) {</p>
<p>  a[j+1] = a[j];  // 数据移动</p>
<p>} else {</p>
<p>  break;</p>
<p>}</p>
把执行一个赋值语句的时间粗略的计为单位时间，然后分别用冒泡排序和插入排序对同一个逆序度是k的数组进行排序。
冒泡排序需要k次交换操作，每次需要三个赋值操作，所以交换操作总耗时是3*k单位时间，而插入排序中数据移动操作只需要k个单位时间。
所以插入排序一般比冒泡排序要快很多，而且冒泡排序还有优化版本希尔排序。
