<h2>线性排序</h2>
桶排序、计数排序、基数排序，这三种排序算法的时间复杂度都是是 O(n)，因为这些排序算法的时间复杂度是线性的
，所以我们把这类排序算法叫作线性排序（Linear sort）。之所以能做到线性的时间复杂度，主要原因是，
这三个算法是<h2>非基于比较的排序算法，都不涉及元素之间的比较操作。</h2>
<p>如何根据年龄给 100 万用户排序？</p>
 归并、快排就可以搞定啊！是的，它们也可以完成功能，但是时间复杂度最低也是 O(nlogn)。有没有更快的排序方法呢？让我们一起进入今天的内容！
 <h2>桶排序（Bucket sort）</h2>
 <p>核心思想是将要排序的数据分到几个有序的桶里，每个桶里的数据再单独进行排序，桶内拍完序之后，再把每个桶里的数据按照顺序依次取出，组成的序列就是有序的了</p>
 <p>桶排序的时间复杂度是O(n)</p>
 如果要排序的数据有n个，均匀地划分到m个桶里，每个桶里就有k=n/m个元素，每个桶内部使用快速排序，时间复杂度为O(k*logk)m个桶排序的
 时间复杂度就是O(m*k*logk),因为k=n/m，所以整个桶排序的时间复杂度就是O(n*log(n/m))。当桶的个数m接近数据个数n时，log(n/m)就是一个非常小的容量，这个时候桶排序的时间复杂度接近O(n)。
 <p>桶排序对排序数据的要求是非常苛刻的</p>
 <li>要排序的数据需要很容易就能划分成m个桶</li>
  <li>桶与桶之间有着天然的大小顺序，这样每个桶内的数据都拍完序之后，桶与桶之间的数据就不要再进行排序</li>
  如果数据在各个桶之间的分布不是均匀地，极端情况下，所有的数据都被划分到一个桶里，那就被退化为O(nlogn)的排序算法了
  <h3>桶排序比较适合用在外部排序中</h3>
  外部排序就是数据存储在外部磁盘中，数据量比较大，内存有限，只有几百MB，没办法把一次性把10GB的数据都加载到内存中，这个时候就可以
  借助桶排序的处理思想来解决这个问题。
  <p>可以先扫描一遍文件，获取订单金额所处的数据范围，假设经过扫描之后，订单金额最小是1元，再大是10万元，将所有的订单根据金额划分到100个桶里</p>
  <p>第一个桶存放1-1000元之内订单，第二个是1001到2000以此内推，每个桶对应一个文件，并且按照金额范围的大小顺序编号命名(00 01 02 99)</p>
  每个桶如果内容过多可以再细细划分，这样，每次加载一个桶里的文件到内存中，进行排序，每个桶都排完序之后，再根据编号写到一个文件里就可以了
  <p>计数排序(Counting sort)</p>
  个人认为 计数排序是桶排序的一种特殊情况 。当要排序的 n 个数据，所处的范围并不大的时候，比如最大值是 k，我们就可以把数据划分成 k 个桶。每个桶内的数据值都是相同的，省掉了桶内排序的时间。
  <p>我们都经历过高考，高考查分数系统你还记得吗？我们查分数的时候，系统会显示我们的成绩以及所在省的排名。如果你所在的省有 50 万考生，如何通过成绩快速排序得出名次呢？</p>
<p>考生的满分是 900 分，最小是 0 分，这个数据的范围很小，所以我们可以分成 901 个桶，对应分数从 0 分到 900 分。根据考生的成绩，我们将这 50 万考生划分到这 901 个桶里。桶内的数据都是分数相同的考生，所以并不需要再进行排序。我们只需要依次扫描每个桶，将桶内的考生依次输出到一个数组中，就实现了 50 万考生的排序。因为只涉及扫描遍历操作，所以时间复杂度是 O(n)。</p>
<p>计数排序的算法思想就是这么简单，跟桶排序非常类似，只是桶的大小粒度不一样。不过，为什么这个排序算法叫“计数”排序呢？“计数”的含义来自哪里呢？</p>

<h2>其实是把每个桶变成了一个数组的每一个节点，桶排序每个桶存放的是一个范围内的数据本体，而计数排序由于范围较小，所以每一个桶存储数据的范围是1，是一个确定的值，在计数排序中，桶就是数组的每一个节点，每个节点的下标就是这个确定的值的值，存放的值开始是这个下标在要排序的数据里出现的次数，然后在依次求和，表示小于等于这个数的个数</h2>
再依次 从后往前 扫描这个要排序的数组，取出数组里的值，当做计数数组的下标进行取值，数组里这个下标对标的值减1，如取c[3]=7，代表要排序的数据里小于等于3的值有7个。第一个3放在第7位，c[3]的值减一就是6，代表小于等于3的个数还有6个，第二次扫描到3时就会放在第6位。。。
计数排序只能用在数据范围不大的场景，如果数据范围 k 比要排序的数据 n 大很多，就不适合用计数排序了。而且，排序只能给非负整数(数组的下标没有负数)，如果要排序的数据是其他类型的，要其在不改变相对大小的情况下，转化为非负整数。
比如，还是拿考生这个例子。如果考生成绩精确到小数后一位，我们就需要将所有的分数都先乘以 10，转化成整数，然后再放到 9010 个桶内。再比如，如果要排序的数据中有负数，数据的范围是 [-1000, 1000]，那我们就需要先对每个数据都加 1000，转化成非负整数。
<h2>基数排序(Redix sort)</h2>
假设我们有 10 万个手机号码，希望将这 10 万个手机号码从小到大排序，你有什么比较快速的排序方法呢？
快排，时间复杂度可以做到 O(nlogn)，还有更高效的排序算法吗？桶排序、计数排序能派上用场吗？手机号码有 11 位，范围太大，显然不适合用这两种排序算法。针对这个排序问题，有没有时间复杂度是 O(n) 的算法呢？基数排序。
<p>刚刚这个问题里有这样的规律：假设要比较两个手机号码 a，b 的大小，如果在前面几位中，a 手机号码已经比 b 手机号码大了，那后面的几位就不用看了。</p>
先按照最后一位来排序手机号码，然后，再按照倒数第二位重新排序，以此类推，最后按照第一位重新排序。经过 11 次排序之后，手机号码就都有序了
<p>注意，这里按照每位来排序的排序算法要是稳定的，否则这个实现思路就是不正确的。因为如果是非稳定排序算法，那最后一次排序只会考虑最高位的大小顺序，完全不管其他位的大小关系，那么低位的排序就完全没有意义了。</p>
<p>根据每一位来排序，我们可以用刚讲过的桶排序或者计数排序，它们的时间复杂度可以做到 O(n)。如果要排序的数据有 k 位，那我们就需要 k 次桶排序或者计数排序，总的时间复杂度是 O(k*n)。当 k 不大的时候，比如手机号码排序的例子，k 最大就是 11，所以基数排序的时间复杂度就近似于 O(n)。</p>
<p>实际上，有时候要排序的数据并不都是等长的，比如我们排序牛津字典中的 20 万个英文单词，最短的只有 1 个字母，最长的我特意去查了下，有 45 个字母，中文翻译是尘肺病。对于这种不等长的数据，基数排序还适用吗？</p>
<p>实际上，我们可以把所有的单词补齐到相同长度，位数不够的可以在后面补“0”，因为根据ASCII值，，所有字母都大于“0”，所以补“0”不会影响到原有的大小顺序。这样就可以继续用基数排序了。</p>
<h2>基数排序对要排序的数据是有要求的，需要可以分割出独立的“位”来比较，而且位之间有递进的关系，如果 a 数据的高位比 b 数据大，那剩下的低位就不用比较了。除此之外，每一位的数据范围不能太大，要可以用线性排序算法来排序，否则，基数排序的时间复杂度就无法做到 O(n) 了</h2>

<p>如何根据年龄给百万用户排序？</p>
假设年龄的范围最小1岁最大不超过120岁，可以遍历这100万用户，根据年龄将其划分到这120个桶里，然后依次顺序遍历这120个桶中的元素，这样就得到了按照年龄排序的100万用户

<p> 3 种线性时间复杂度的排序算法，有桶排序、计数排序、基数排序。它们对要排序的数据都有比较苛刻的要求，应用不是非常广泛。但是如果数据特征比较符合这些排序算法的要求，应用这些算法，会非常高效，线性时间复杂度可以达到 O(n)。</p>
<p>桶排序和计数排序的排序思想是非常相似的，都是针对范围不大的数据，将数据划分成不同的桶来实现排序。基数排序要求数据可以划分成高低位，位之间有递进关系。比较两个数，我们只需要比较高位，高位相同的再比较低位。而且每一位的数据范围不能太大，因为基数排序算法需要借助桶排序或者计数排序来完成每一个位的排序工作。</p>
