<h2>排序 slave132</h2>
<img src="https://static001.geekbang.org/resource/image/fb/cd/fb8394a588b12ff6695cfd664afb17cd.jpg"/>
插入排序和冒泡排序的时间复杂度相同都是O(n2)，在实际的软件开发中，为什么更倾向于使用插入排序而不是冒泡排序？
<p>分析排序算法的执行效率</p>
<li>最好情况，最坏情况，平均情况时间复杂度</li>
<li>时间复杂度的系数,常数，低阶</li>
<li>比较次数和交换(或移动)次数</li>
<p>排序算法的内存消耗</p>
原地排序算法特指空间复杂度是O(1)的排序算法
<p>排序算法的稳定性，如果待排序的序列中存在值相等的元素，在经过排序之后，相等元素之间原有的先后顺序不变</p>
冒泡排序中数据的交换操作：
<p>  if (a[j] > a[j+1]) { // 交换</p>
<p>  int tmp = a[j];</p>
<p>  a[j] = a[j+1];</p>
<p>   a[j+1] = tmp;</p>
<p>  flag = true;</p>
<p>  }</p>

插入排序中数据的移动操作：
<p>if (a[j] > value) {</p>
<p>  a[j+1] = a[j];  // 数据移动</p>
<p>} else {</p>
<p>  break;</p>
<p>}</p>
把执行一个赋值语句的时间粗略的计为单位时间，然后分别用冒泡排序和插入排序对同一个逆序度是k的数组进行排序。
冒泡排序需要k次交换操作，每次需要三个赋值操作，所以交换操作总耗时是3*k单位时间，而插入排序中数据移动操作只需要k个单位时间。
所以插入排序一般比冒泡排序要快很多，而且冒泡排序还有优化版本希尔排序。
<p>o(nlogn)的排序算法，归并排序和快速排序，都比较适合大规模的数据</p>
<p>归并排序和快速排序都用到了分治的思想</p>
<p>归并排序的原理</p>
<p>将数组从中间分为前后两个部分，然后对前后两部分分别进行排序，再讲排好序的两部分合并在一起，这样整个数组就有序了</p>
<img src="https://static001.geekbang.org/resource/image/db/2b/db7f892d3355ef74da9cd64aa926dc2b.jpg"/>
<p>分治:分而治之，将一个大问题分解成小的子问题来解决，小的问题解决了，大的问题也就解决了</p>
分治思想和递归思想很像，分治思想一般都是用递归来实现的。
<p>分治是一种解决问题的处理思想，递归时一种编程技巧，并不冲突。</p>
<p>
递推公式：
merge_sort(p…r) = merge(merge_sort(p…q), merge_sort(q+1…r))
终止条件：
p >= r 不用再继续分解
</p>
<p>归并排序是否是稳定排序？归并排序稳不稳定关键要看 merge() 函数，也就是两个有序子数组合并成一个有序数组的那部分代码。</p>
<p>在合并的过程中，如果 A[p…q] 和 A[q+1…r] 之间有值相同的元素，那我们可以像伪代码中那样，先把 A[p…q] 中的元素放入 tmp 数组。这样就保证了值相同的元素，在合并前后的先后顺序不变。所以，归并排序是一个稳定的排序算法。</p>
<p>时间复杂度</p>
<p>   T(n) = 2*T(n/2) + n</p> 
 <p>      = 2*(2*T(n/4) + n/2) + n = 4*T(n/4) + 2*n</p> 
 <p>      = 4*(2*T(n/8) + n/4) + 2*n = 8*T(n/8) + 3*n</p> 
 <p>      = 8*(2*T(n/16) + n/8) + 3*n = 16*T(n/16) + 4*n</p> 
 <p>      ......</p> 
 <p>      = 2^k * T(n/2^k) + k * n</p> 
 <p>      ......</p> 
 <p>通过这样一步一步分解推导,我们就可以得到时间复杂度为O(nlogn)，最坏的情况也是nlogn</p>
 <p>由于需要一个临时空间存储合并后值，所以时间复杂度为o(n)</p>
 <p>快速排序的原理</p>
 <p>块排也是利用分治思想，如果要排序数组中下标从p到r之间的一组数据，选择p到r之间的任意一个数据作为pivot(分区点)</p>
<p>我们遍历 p 到 r 之间的数据，将小于 pivot 的放到左边，将大于 pivot 的放到右边，
将 pivot 放到中间。经过这一步骤之后，数组 p 到 r 之间的数据就被分成了三个部分，
前面 p 到 q-1 之间都是小于 pivot 的，中间是 pivot，后面的 q+1 到 r 之间是大于 pivot 的。
</p>
<p>根据分治、递归的处理思想，我们可以用递归排序下标从 p 到 q-1 之间的数据和下标从 q+1 到 r 之间的数据，直到区间缩小为 1，就说明所有的数据都有序了。</p>

</p>
递推公式：
quick_sort(p…r) = quick_sort(p…q-1) + quick_sort(q+1, r)

终止条件：
p >= r
</p>
<p>原理图</p>
<img src="https://static001.geekbang.org/resource/image/08/e7/086002d67995e4769473b3f50dd96de7.jpg"/>

<p>快速排序和归并排序的区别？</p>
两者虽然都是基于分治思想，但仍然有不同。
<p>
<img src="https://static001.geekbang.org/resource/image/aa/05/aa03ae570dace416127c9ccf9db8ac05.jpg"/>
</p>
<p>可以发现，归并排序的处理过程是<strong>由下到上</strong>的，先处理子问题，然后再合并。而快排正好相反，它的处理过程是由上到下
的，先分区，然后再处理子问题。归并排序虽然是稳定的、时间复杂度为 O(nlogn) 的排序算法，但是它是非原地排序算法。
我们前面讲过，归并之所以是非原地排序算法，主要原因是合并函数无法在原地执行。快速排序通过设计巧妙的原地分区函数，
可以实现原地排序，解决了归并排序占用太多内存的问题。
</p>
<p>快排是原地，不稳定的排序算法</p>
<p>时间复杂度分析</p>
如果每次分区操作，都能正好把数组分成大小接近相等的两个小区间，那快排的时间复杂度递推求解公式
跟归并是相同的。所以，快排的时间复杂度也是 O(nlogn)。
<p>但是，公式成立的前提是每次分区操作，我们选择的 pivot 都很合适，正好能将大区间对等地一分为二。但实际上这种情况是很难实现的。</p>
一个比较极端的例子。如果数组中的数据原来已经是有序的了，比如 1，3，5，6，8。如果我们每次选择最后一个元素作为 pivot，那每次分区得到的两个区间都是不均等的。我们需要进行大约 n 次分区操作，才能完成快排的整个过程。
每次分区我们平均要扫描大约 n/2 个元素，这种情况下，快排的时间复杂度就从 O(nlogn) 退化成了 O(n<sup>2</sup>)

<p>如何在 O(n) 的时间复杂度内查找一个无序数组中的第 K 大元素？</p>
快排核心思想就是合并和分区，我们可以使用分区的思想来解决此问题。
<p>我们选择数组区间 A[0…n-1] 的最后一个元素 A[n-1] 作为 pivot，对数组 A[0…n-1] 原地分区，这样数组就分成了三部分，A[0…p-1]、A[p]、A[p+1…n-1]。</p>
<p>如果 p+1=K，那 A[p] 就是要求解的元素；如果 K>p+1, 说明第 K 大元素出现在 A[p+1…n-1] 区间，我们再按照上面的思路递归地在 A[p+1…n-1] 这个区间内查找。同理，如果 K<p+1，那我们就在 A[0…p-1] 区间查找。</p>
<p>我们再来看，为什么上述解决思路的时间复杂度是 O(n)？</p>
<p>第一次分区查找，我们需要对大小为 n 的数组执行分区操作，需要遍历 n 个元素。第二次分区查找，我们只需要对大小为 n/2 的数组执行分区操作，需要遍历 n/2 个元素。依次类推，分区遍历元素的个数分别为、n/2、n/4、n/8、n/16.……直到区间缩小为 1。</p>
<p>如果我们把每次分区遍历的元素个数加起来，就是：n+n/2+n/4+n/8+…+1。这是一个等比数列求和，最后的和等于 2n-1。所以，上述解决思路的时间复杂度就为 O(n)。</p>
<p>归并排序算法是一种在任何情况下时间复杂度都比较稳定的排序算法，这也使它存在致命的缺点，即归并排序不是原地排序算法，空间复杂度比较高，是 O(n)。正因为此，它也没有快排应用广泛。</p>
<p>快速排序算法虽然最坏情况下的时间复杂度是 O(n<sup>2</sup>)，但是平均情况下时间复杂度都是 O(nlogn)。不仅如此，快速排序算法时间复杂度退化到 O(n<sup>2</sup>) 的概率非常小，我们可以通过合理地选择 pivot 来避免这种情况。</p>


<h2>排序算法的稳定性</h2>
<p>稳定性算法:   基数排序 , 直接插入排序 , 冒泡排序, 归并排序</p>
<p>不稳定性算法: 桶排序,    二分插入排序,希尔排序, 快速排序,   简单选择排序,堆排序</p>
1.只要不涉及到两个元素之间位置的交换就肯定是稳定的排序算法.比如归并排序,基数排序.(桶排序不稳定是个特例,因为它丢失了附带信息,不然的话可以弄成稳定排序的)

2.在涉及到不同位置元素交换的算法中除了冒泡和直接插入排序是稳定的,其他都是不稳定的.
你可以这样想,之所以出现相同元素位置变了就是其中一个交换位置时从另一个头顶跳过去了,而冒泡算法是相邻位置互换,跳不过去的,碰到相等元素的时候就停住不交换了.

而直接插入排序是往已排好序的序列中插入.所以你通过由后往前遍历碰到相等的时就停住,这样也能保持稳定.但记住一定得从后往前遍历,不然也会不稳定.(所以说直接插入是半稳吧,而冒泡是非常的稳啊,除非你闲得蛋痛非得把两相等的元素两两交换)

 
<img src="https://static001.geekbang.org/resource/image/1f/fd/1f6ef7e0a5365d6e9d68f0ccc71755fd.jpg"/>
