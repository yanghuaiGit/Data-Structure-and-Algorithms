<h2>递归</h2>
递归需要满足的三个条件：
<li>一个问题的解可以分为几个子问题解</li>
<li>这个问题与分解之后的子问题，除了数据规模的不同，求解思路是一致的</li>
<li>存在递归终止条件</li>

如何编写递归代码？
写出递推公式，找到终止条件。
<p>递归代码要警惕堆栈溢出</p>
函数调用会使用栈来保存临时变量。每调用一个函数，都会将临时变量封装为栈帧压入内存栈，
0等函数执行完成返回时，才出栈。系统栈或者虚拟机栈空间一般都不大.如果递归求解的数据规模很大，调用层次很深，一直压入栈，就会有
堆栈溢出的风险。 
<p>可以通过限制递归调用 的最大深度的方式来解决这个问题</p>
<P>递归代码要避免重复计算</P>
<img src="https://static001.geekbang.org/resource/image/e7/bf/e7e778994e90265344f6ac9da39e01bf.jpg"/>
如图所示,f(3)被计算了多次，为了避免重复计算，可以使用一个数据结构(如散列表)来保存已经求解过的f(k)。当递归调用到f(k)时
，先看下是否已经求解过了。如果是，则直接从散列表中取值返回，不需要重复计算，这样就能避免这种问题。
<p>递归代码其他问题：
   在函数调用的数量较大时，就会积聚成一个可观的时间成本同时在空间复杂度上，每一次递归的调用都会在内存栈中
   保存一次现场数据，所以分析递归代码空间复杂度时，需要额外考虑这部分开销。
 </p>
 如何将递归代码改写为非递归代码？
 <p>可以将递归代码修改为迭代循环代码，因为递归本身就是借助栈来实现的，只不过我们使用的栈是系统或者虚拟机本身提供的，如果我们自己在内存堆
 上实现栈，手动模拟入栈，出栈过程，这样任何递归代码都可以改写成看上去不是递归代码的样子</p>

