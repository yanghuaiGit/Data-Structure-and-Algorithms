<h1>数组</h1>

数组是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据

<h2>基本特性</h2>
    <li>线性表：每个线性表上的数据最多只有前和后两个方向 链表，队列，栈</li>
    <li> 连续的内存空间和相同类型的数据：保证了随机访问的特性</li>
<p></p>  
<h3>数组如何实现根据下标随机访问数组元素</h3>                                                                                           
   计算机会给每个内存单元分配一个地址，计算机通过地址来访问内存中的数据。当计算机需要随机访问数组中的元素的时候，
   它会通过下面的寻址公式，计算出该元素存储的内存地址
   
    a[i]_address = base_address + i * data_type_size
    
   data_type_size表示数组中每个元素大小，如int类型就是4个字节大小</p>


数组适合查找，其时间复杂度为O(1)，事实上，这种表述是不准确的。数组是适合查找操作，但是查找复杂度并不为O(1)，即使是排好序的数组，
用二分查找时间复杂度也是O(logn)。所以正确的表述是:
 <p>
数组支持随机访问，根据下标随机访问的时间复杂度为O(1) 
</p>

<h3>低效的 插入 和 删除</h3>
<li>插入操作</li>
<p></p>
如果将一个数据插入到数组中的第K个位置，为了把第k个位置腾出给新来的数据，需要将k-n这部分的元素都顺序地往后挪一位。
<p>如果在数组的末尾插入元素，那就不需要移动数据，这时候时间复杂度为O(1)，如果是数组的开头插入就是O(n)，平均复杂度为O(n)</p>
<p>如果数据中的数据是有序的，插入数据按照上面的步骤，如果是无序的，仅仅是存储数据的集合，那么可以将某个数据插入到第K位的操作优化</p>
<P>直接将第K位的数据搬移到数组元素的最后，将新的元素直接放入第K个位置</P>

<li>删除操作</li>
<p>
和插入类似，平均时间复杂度为O(n)，优化思路:每次删除都是假删除，那么就不需要删除的同时搬移数据，记录一下，
当数组没有更多空间存储数据时候，再触发一次真正的删除操作，类似于JVM标记清除垃圾回收算法的核心思想
</p>

<h3>警惕数组越界问题</h3>
<h3>容器能否完全替代数组</h3>
<li>ArrayList 无法存储基本类型，需要封装为对象如integer，而拆箱装箱时有一定的性能消耗的</li>
<li>表示多维数组时，用数组会更加直观</li>