<head>链表</head>

使用链表实现LRU淘汰缓冲策略(常见的策略有 先进先出FIFO(first in first out)，最少使用策略LFU(Least Frequently Used),最近最少使用策略LRU（Least Recently Used）

链表不需要一块连续的内存空间，通过指针，将一组零散的内存块串联起来使用。
<p>在进行数组的插入，删除的操作时，为了保持内存数据的连续性，需要做大量的数据搬移，所以复杂度是O(n)而在链表中插入或者删除一个数据，不需要为了保持内存的连续性而搬移结点，因为链表的存储空间本身就不是连续的，所以在链表中插入和删除一个数据是非常快速的，一般来说，链表的插入和删除操作只需要考虑相邻结点的指针改变，所以对应的时间复杂度是O(1)</P>

常见的三种链表结构：
    <li>单链表</li>
    <li> 双向链表</li>
    <li> 循环链表</li>
  
 <p>单链表</p>                                                                                           
    链表通过指针将一组零散的内存块串联在一起，内存块称为链表的结点。为了将所有的结点串起来，每个链表的结点除了存储数据之外，还需要记录链上的下一个节点的地址，称为后继指针 next。
   
   有两个指针是比较特殊的，分别是第一个以及最后一个，即头结点以及尾结点，其中头结点记录链表的基地址，通过它可以遍历整条链表，尾结点特殊的是后继节点不是指向下一个结点，而是指向一个空节点null，表示这是链表上最后一个节点。
                                                                               
