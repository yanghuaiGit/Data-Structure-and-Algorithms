<head>链表</head>

使用链表实现LRU淘汰缓冲策略(常见的策略有 先进先出FIFO(first in first out)，最少使用策略LFU(Least Frequently Used),最近最少使用策略LRU（Least Recently Used）

链表不需要一块连续的内存空间，通过指针，将一组零散的内存块串联起来使用。
<p>在进行数组的插入，删除的操作时，为了保持内存数据的连续性，需要做大量的数据搬移，所以复杂度是O(n)而在链表中插入或者删除一个数据，不需要为了保持内存的连续性而搬移结点，因为链表的存储空间本身就不是连续的，所以在链表中插入和删除一个数据是非常快速的，一般来说，链表的插入和删除操作只需要考虑相邻结点的指针改变，所以对应的时间复杂度是O(1)</P>

常见的三种链表结构：
    <li>单链表</li>
    <li> 双向链表</li>
    <li> 循环链表</li>
  
 <p>单链表</p>                                                                                           
    链表通过指针将一组零散的内存块串联在一起，内存块称为链表的结点。为了将所有的结点串起来，每个链表的结点除了存储数据之外，还需要记录链上的下一个节点的地址，称为后继指针 next。
   
   有两个指针是比较特殊的，分别是第一个以及最后一个，即头结点以及尾结点，其中头结点记录链表的基地址，通过它可以遍历整条链表，尾结点特殊的是后继节点不是指向下一个结点，而是指向一个空节点null，表示这是链表上最后一个节点。
   <p>循环列表</p>
   循环列表相比单链表是一种特殊的单链表，和单链表的唯一区别是尾结点的后继指针指向头结点。
   <p>优点是从链尾到链头比较方便，当要处理的数据具有环型结构特点时，就特别适合采用循环链表，比如著名的约瑟夫问题</p>                                                                          
 实际开发更经常使用的结构：双向链表，每个结点不仅有后继节点指向下一个结点，还有一个前驱指针指向前一个结点
 <p>从结构上来看，双向链表可以支持O(1)时间复杂度的情况下找到前驱结点，正是这样的特点，使双向链表早某些情况下的插入，删除操作都要比单链表简单高效。</p>

 单向链表的插入，删除操作的时间复杂度已经是O(1)了，双向链表怎么还能再高效？
<p>实际开发中，删除数据2种情况</p>
 <li>删除结点中"值等于某个给定值"的结点</li>
 <li>删除给定指针指向的结点</li>
 <p>第一种情况需要遍历查找相同的值，消耗主要是遍历的时间消耗，对应的时间复杂度是O(n)，因此整个删除操作的时间复杂度是O(n)。</p>
 <p>第二种情况已经找到需要删除的结点，但是删除某个结点需要知道它的前驱结点，而单链表不支持直接获取前驱结点，所以为了找到前驱结点，我们需要从头结点开始遍历链表，直到p->next+q，说明p是q的前驱结点。但是对于双向链表来说，这种情况比较有优势。因为双向链表的结点已经保存了前驱结点的指针，不需要像单链表那样遍历。所以，针对第二种情况，单链表删除操作需要O(n)的时间复杂度，而双向链表只需要在O(1)的时间复杂度内就搞定了</p>
同理添加操作也是一样
<p>对于一个有序链表，双向链表的按值查询的效率也要比单链表高一些。因为，我们可以记录上次查找的位置 p，每次查询时，根据要查找的值与 p 的大小关系，决定是往前还是往后查找，所以平均只需要查找一半的数据。</p>
<p>双向循环链表</p> 
