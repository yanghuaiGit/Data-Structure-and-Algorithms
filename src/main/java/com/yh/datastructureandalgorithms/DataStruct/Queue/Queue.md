<p>通过线程池的应用了解队列</p>
先进者先出就是典型的队列
<p>队列和栈一样只支持两个操作</p>
<ul>
<li>入队enqueue</li>
<li>出队dequeue</li>
</ul>
所以队列和栈一样是操作受限的线性表数据结构
<p>顺序队列和链式队列</p>
数组实现的队列是顺序队列，链表实现的是链式队列

<p>循环队列</p>
用数组来实现队列的时候，在 tail==n 时，会有数据搬移操作，
这样入队操作性能就会受到影响。那有没有办法能够避免数据搬移呢？
我们来看看循环队列的解决思路。
循环队列演示图
<img src="https://static001.geekbang.org/resource/image/71/80/71a41effb54ccea9dd463bde1b6abe80.jpg"/>
<p>循环队列难点在于确定好队空和队满的判定条件：(tail+1)%n=head</P>
<p>阻塞队列和并发队列</P>
<li>其实就是在队列基础上增加了阻塞操作。简单来说，就是在队列为空的时候，从队头取数据会被阻塞。
因为此时还没有数据可取，直到队列中有了数据才能返回如果队列已经满了，那么插入数据的操作就会被
阻塞，直到队列中有空闲位置后再插入数据，然后再返回。
</li>
<li>线程安全的队列就是并发队列。。最简单直接的实现方式是直接在 enqueue()、dequeue() 方法上加锁，
但是锁粒度大并发度会比较低，同一时刻仅允许一个存或者取操作。实际上，基于数组的循环队列，
利用 CAS 原子操作，可以实现非常高效的并发队列。这也是循环队列比链式队列应用更加广泛的原因。
</LI>
<p>
基于链表的实现方式，可以实现一个支持无限排队的无界队列（unbounded queue），但是可能会导致过多
的请求排队等待，请求处理的响应时间过长.所以，针对响应时间比较敏感的系统，
基于链表实现的无限排队的线程池是不合适的。
</p>
<p>
而基于数组实现的有界队列（bounded queue），队列的大小有限，所以线程池中排队的请求超过队列大小时，
接下来的请求就会被拒绝，这种方式对响应时间敏感的系统来说，就相对更加合理。不过，设置一个合理的队列大小，也是非常有讲究的。
队列太大导致等待的请求太多，队列太小会导致无法充分利用系统资源、发挥最大性能。</P>
